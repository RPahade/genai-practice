import asyncio
import json
import os
from typing import List, Dict, Any
from sqlalchemy.orm import Session
from backend.models.models import Job, Report
from backend.core.database import SessionLocal
import logging
from pypdf import PdfReader

# Real Tools
class ToolRegistry:
    def __init__(self):
        self.logger = logging.getLogger(__name__)

    async def web_search(self, query: str) -> str:
        tavily_key = os.getenv("TAVILY_API_KEY")
        if not tavily_key:
            # Return a realistic looking mock search result
            mock_results = [
                {"title": f"Recent Advances in {query}", "url": "https://example.com/advances", "content": f"This article discusses the latest trends in {query}."},
                {"title": f"Understanding {query}: A Comprehensive Guide", "url": "https://example.com/guide", "content": f"A deep dive into the core concepts of {query}."},
                {"title": f"Key Challenges in {query}", "url": "https://example.com/challenges", "content": f"Analysis of the primary obstacles facing the {query} industry."}
            ]
            return json.dumps(mock_results, indent=2)
        
        try:
            from tavily import TavilyClient
            tavily = TavilyClient(api_key=tavily_key)
            response = tavily.search(query=query, search_depth="advanced")
            return json.dumps(response.get("results", []), indent=2)
        except Exception as e:
            self.logger.error(f"Tavily search failed: {e}")
            return f"Search failed: {e}"

    async def pdf_ingest(self, file_path: str) -> str:
        if not file_path or not os.path.exists(file_path):
            return ""
        
        try:
            reader = PdfReader(file_path)
            text = ""
            for page in reader.pages:
                text += page.extract_text() + "\n"
            return text[:10000] # Limit text to avoid token limits for now
        except Exception as e:
            self.logger.error(f"PDF ingest failed: {e}")
            return f"PDF reading failed: {e}"

    async def report_generator(self, topic: str, search_data: str, pdf_data: str) -> str:
        openai_key = os.getenv("OPENAI_API_KEY")
        if not openai_key:
            # Generate a rich mock report
            pdf_context = f"analyzed the uploaded PDF ({len(pdf_data)} characters)" if pdf_data else "no PDF was uploaded"
            
            return f"""# Research Report: {topic}

## Executive Summary
This report provides a comprehensive analysis of **{topic}**. The findings are based on a simulated web search and {pdf_context}.

## Key Findings
1.  **Overview**: {topic} is a significant subject with broad implications.
2.  **Trends**: Recent data suggests a growing interest in this area.
3.  **Analysis**:
    *   The web search revealed multiple relevant sources.
    *   {f"The uploaded document provided specific context regarding {topic}." if pdf_data else "External data sources were primarily used for this analysis."}

## Detailed Analysis
### Web Search Insights
The search for "{topic}" yielded several key results, indicating active discussion in the field.

### Document Insights
{f"The uploaded PDF contained detailed information that has been incorporated into this summary." if pdf_data else "No specific document insights were available."}

## Conclusion
In conclusion, **{topic}** represents a key area of study. Further research is recommended to explore specific sub-topics.

---
*Generated by Multi-Agent Research Platform (Mock Mode)*
"""

        try:
            from openai import OpenAI
            client = OpenAI(api_key=openai_key)
            
            prompt = f"""
            You are a professional research assistant. Write a comprehensive report on the topic: "{topic}".
            
            Use the following information to write the report:
            
            --- WEB SEARCH RESULTS ---
            {search_data}
            
            --- UPLOADED DOCUMENT CONTENT ---
            {pdf_data}
            
            Format the report in Markdown. Include citations where possible.
            """
            
            response = client.chat.completions.create(
                model="gpt-4o",
                messages=[
                    {"role": "system", "content": "You are a helpful researcher."},
                    {"role": "user", "content": prompt}
                ]
            )
            return response.choices[0].message.content
        except Exception as e:
            self.logger.error(f"OpenAI generation failed: {e}")
            return f"Report generation failed: {e}"

tool_registry = ToolRegistry()

class AgentService:
    def __init__(self):
        self.logger = logging.getLogger(__name__)

    async def run_job(self, job_id: int):
        db: Session = SessionLocal()
        job = db.query(Job).filter(Job.id == job_id).first()
        if not job:
            self.logger.error(f"Job {job_id} not found")
            return

        try:
            job.status = "running"
            db.commit()
            
            # 1. Ingest Documents
            pdf_content = ""
            if job.file_path:
                pdf_content = await tool_registry.pdf_ingest(job.file_path)
            
            # 2. Web Research
            search_result = await tool_registry.web_search(job.topic)
            
            # 3. Generate Report
            report_content = await tool_registry.report_generator(job.topic, search_result, pdf_content)
            
            # Save Report
            report = Report(
                job_id=job.id,
                title=f"Report on {job.topic}",
                content=report_content,
                citations={"source": "AI Generated"}
            )
            db.add(report)
            
            job.status = "completed"
            job.result = {"report_id": report.id}
            db.commit()
            
        except Exception as e:
            self.logger.error(f"Job failed: {e}")
            job.status = "failed"
            db.commit()
        finally:
            db.close()

agent_service = AgentService()
